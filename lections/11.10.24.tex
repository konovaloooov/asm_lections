\section{11.10.2024 лекция 6}
\subsection{Команды условной передачи управления}
фото 1
Примеры:

\begin{minted}{asm}
    JE M1 ;передача управления на команду с меткой М1, если ZF = 1
    JNE M2 ;передача управления на команду с меткой М2, если ZF = 0
    JC M3 ;передача управления на команду с меткой М3, если CF = 1
    JNC M4 ;передача управления на команду с меткой М4, если CF = 0
        ADD AX, BX
        JC M
\end{minted}
если в результате сложения CF = 1, то управление передается на команлду с меткой М, иначе "--- на команду, следующую за JNC
\begin{minted}{asm}
    SUB AX, BX
    JZ Met
\end{minted}
фото2 
фото3 таблица
\subsection{Команды управления}
Команды условной передачи упралвения могут осуществлять только короткий переход, а команды безусловной передачи упраавления могут реализовать как короткую передачу так и длинную. Если необходимо осуществить условный дальний переход, то можно использовать jx вместе jmp следующим образом:
\begin{minted}{asm}
    if AX = BX goto m 
    if AX <> BX goto L 
    Goto m      ;
    ------------------
    L: --------------- ;
\end{minted}
На Ассемблере это будет так:
\begin{minted}{asm}
    cmp AX, BX
    jne
    
\end{minted}

С помощью команд jx jmp можно реализовать цикл с предусловием:
\begin{minted}{asm}
    while x > 0 do S;
        beg:    cmp x, byte ptr 0
                jle fin 
                    S 
                jmp beg 
        fin:    ------------------
    
\end{minted}
и постусловием:
\begin{minted}{asm}
    do S while x > 0;
        beg:     
                    S 
                    cmp x, byte ptr 0
                    jg beg
        fin:        ------------------
\end{minted}
\subsection{Команды для организации циклов}
\begin{enumerate}
    \item loop<метка>
    \item loope<метка>      loopz<метка>
    \item loopne<метка>     loopnz<метка>
\end{enumerate}
По команде в форме 
\begin{enumerate}
    \item (CX) = (CX) - 1 и если (CX) <> 0, <метка>
    \item (CX) = (CX) - 1 и если (CX) <> 0 и одновременно ZF = 1, <метка> 
    
    Цикл завершается, если или (СХ) = 0 или ZF = 0 или (CX) = (ZF) = 0
    \item (CX) = (CX) - 1 и если (CX) <> 0 и одновременно ZF = 0, <метка> 
    
    Выход из цикла осуществляется, если или (CX) = 0 или ZF = 1 или одновременно (CX) = 0 и (ZF) = 1
\end{enumerate}
Примеры: (фото)

\subsection{Примеры использования команд условного перехода, сравнения и циклов}
Дана матрица целых байтовых величин, размером 4*5, необходимо подсчитать количество нулей в каждой строке и заменить их числом 0FFh. Под стек отведёс 256 байтов, программу оформим как две последовательные процедуры: внешняя (FAR) "--- это связь с ОС, внутренняя (NEAR) "--- решение поставленнной задачи
\begin{minted}{asm}
    ;prim.asm
    title prim.asm
    page , 132
    Sseg segment para stack 'stack'
            db 256 dup(?)
    Sseg ends
    Dseg segment para public 'data'
    Dan db 0,2,5,0,91 ;адрес первого элемента массива
            db 4,0,0,15,47 ; имя "--- Dan
            db 24,15,0,9,55
            db 1,7,12,0,4
    Dseg ends
    Cseg segment para public 'code'
            Assume cs:cseg, ds:dseg, ss:sseg
    start proc far 
            push DS     ;для связи
            push AX     ;с ОС
            mov BX, Dseg;загрузка адреса сегмента данных
            mov DS, BX  ;в регистр DS
            call main
            ret
    start endp
    main proc near 
                    mov BX, offset Dan
                    mov CX, 4       ;количество повторений внешнего цикла
    nz1: push CX
            mov DL, 0   ;счётчик нулей в строке матрицы
                mov SI, 0
                mov CX, 5   ;количесвто повторений внутреннего цикла
    nz2: push CX
                cmp byte ptr [BX+SI], 0
                jne mz
                mov byte ptr [BX+SI], 0FFh
                ine DL
    mz: ine SI
                pop CX
    kz2: loop nz2
            add DL, '0' ;вывод на экран
            mov AH, 6   ;количество нулей
            int 21h
                add BX, 5   ;переход к следующей строке матрицы
                pop CX
    kz1: loop nz1
                ret
    main endp
    Cseg ends
                end start
\end{minted}

\subsection{Массивы в Ассемблере}
Массивы в языке Ассемблер описывается директивами определения данных, возможно с использованием конструкции повторения DUP.

Например, \textbf{x DW 30 dup( ? )}

Так можно описать массив х, состоящий из 30 элементов длиной в слово, но в этом описании не указано как нумеруются элементы массива, т.е. это может быть \textbf{х[0..29] и х[1..30] и х[k..29 + k].}

Если в задаче жестко не оговорена нумерация элементов, то в Ассемблере удобнее считать элементы от нуля, тогда адрес любого элемента будет записываться наиболее просто:
\begin{center}
    \textbf{адрес (x[i]) = x + (type x) * i }
\end{center}
фото

С учетом этих формул для записи адреса элемента массива можно использовать различные способы адресации.

Для описанного выше массива слов, адрес его i-го элемента равен:
\begin{center}
    \textbf{x + 2*i = x + type(x) * i}
\end{center}
Т.е. адрес состоит из двух частей: постоянной х и переменной 2 * i, зависящей от номера элемента массива. Логично использовать адресацию прямую с индексированием: х "--- смещение, а 2 * i "--- в регистре модификаторе Si или DI     \textbf{x[i]}

Для двумерного массива, например:
\begin{center}
    \textbf{я}
\end{center}
фото

Фрагмент программы, в которой
фото\dots



\subsection{Команды побитовой обработки данных}
К командам побитовой обработки данных относятся логические команды, команды сдвига, установки, сброса и инверсии битов.

Логические операнды: and, or, xor, not. Для всех логических команд, кроме not, операнды одновременно не могут находиться в памяти, OF = Cf = 0, AF "--- не определён, SF, ZF, PF определяются результатом команды.

\textbf{and OP1, OP2} ; (OP1) логически умножается на (ОР2), результат ОР1

Пример: (AL) = 1011 0011, (DL) = 0000 1111,
\textbf{and AL, DL} ;(AL) = 0000 0011

Второй опреанд называют маской. Основным назначением команды and является установка в ноль с поощью маски некоторых разрядов первого операнда. Нулевые разряды маски обнуляют соответствующие разряды первого операнда, а единичные оставляют соответствующие разряды первого операнда без изменения. Маску можно задавать непосредственно в команде и модно извлекать из регистра или памяти.

Например:

\begin{enumerate}
    \item and CX, 0FFh  ;маской является константа
    \item and AX, CX    ;маска содержится в регистре
    \item and AX, TOT   ;маска в ОП по адресу (DS) + TOT
    \item and AX, TOT[BX+SI]    ;\dots в ОП по адресу (DS)+(BX)+(SI)+(TOT) 
    \item and TOT[BX+SI], CX    ; вноль устанавливаются некоторые разряды ОП
    \item and CL, 0Fh    ;в ноль устанавливаются старшие 4 разряда регистра CL
\end{enumerate}

Команда "--- \textbf{or OP1, OP2} ;рез